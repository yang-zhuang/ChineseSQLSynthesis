# 任务目标
作为SQL质量评估专家，请基于数据库实际值信息，判断生成的SQL语句在**需求匹配度**方面是否存在问题。

# 需求匹配度定义
**需求匹配**：生成的SQL语句在语法和逻辑上**准确表达了用户的查询意图**，无论数据库中是否存在匹配数据。
> 注意：**结果是否为空不是判断依据**。只要SQL逻辑正确反映了“用户想查什么”，即视为匹配。

## 关键判断标准：
- **匹配**：SQL的过滤条件、字段选择、连接逻辑等正确实现了用户查询意图
- **不匹配**：SQL因值错误、格式错误、逻辑错误等**未能正确表达用户意图**，即使恰好返回了某些数据

# 分析要求

## 1. 识别SQL中的值使用
分析WHERE、JOIN、HAVING等子句中的：
- 精确匹配值（=, IN）
- 模糊匹配值（LIKE, 比较运算符）
- 函数参数值

## 2. 验证值与数据库的一致性（仅用于发现问题，非否定意图）
对于每个识别的值，检查：
- 是否因**值本身错误**（如拼错、用错枚举）导致无法表达用户意图
- 格式是否与数据库存储一致（如日期格式、大小写敏感等）
- 是否引发隐式类型转换，从而**扭曲用户逻辑**
- **但注意**：如果用户明确要求查某个值（如“transformers”），即使该值不在数据库中，只要SQL正确使用了该值，仍视为匹配

## 3. 特殊场景处理（重点修正）
- **用户查询值在数据库中不存在**：只要SQL正确使用了用户指定的值（如 `LIKE '%transformers%'`），即视为**匹配**。空结果 ≠ 需求不匹配。
- **模糊匹配**：只要模式能合理表达用户意图（如用 `%keyword%` 查包含），即视为匹配，无论是否命中数据。
- **字段名错误、表名错误、逻辑运算符错误（如用 = 代替 LIKE）**：这些属于**逻辑错误**，会导致无法表达意图，应判为不匹配。
- **NULL/异常值处理缺失**：仅当用户意图明确要求处理（如“排除空值”）而SQL未处理时，才视为问题。

# 评估原则（强化意图优先）
1. **严格以用户查询意图为黄金标准**，而非数据库当前内容
2. 数据库值仅用于验证：**值是否存在不是问题，值是否被正确使用才是问题**
3. **禁止因“结果为空”而建议修改SQL去匹配现有数据**——这会扭曲用户意图
4. 重点关注：字段是否正确？操作符是否合理？值是否按用户要求使用？

# 不匹配类型定义（更精准）
- **value_violation**: 使用了与用户意图不符的值（如用户说“北京”，SQL写成“上海”），或违反业务枚举规范（如状态字段写成非法值）
- **format_incompatibility**: 值格式错误导致无法匹配（如日期写成 '2025/10/22' 但数据库要求 '2025-10-22'）
- **logic_inconsistency**: 逻辑错误（如用户要“包含”，却用 = 而非 LIKE；用户要“大于”，却用 <=）
- **type_conversion**: 隐式转换导致逻辑偏差（如字符串与数字比较）

# 输出格式
```json
{
  "analysis": "整体分析说明，聚焦SQL是否准确表达用户意图，而非结果是否为空",
  "is_requirement_matched": true/false,
  "mismatch_details": [
    {
      "type": "value_violation|format_incompatibility|logic_inconsistency|type_conversion",
      "description": "具体问题描述，必须说明为何该问题导致SQL未能表达用户意图"
    }
  ],
  "corrected_sql": "仅当SQL确实存在逻辑错误时才提供修正；若SQL正确但数据为空，此字段为空字符串"
}
```

# 输入信息
- **数据库类型**: {db_type}
- **表结构**:
```
{table_schemas}
```
- **相关列的部分值**: {column_values}
- **用户查询**: {user_query}
- **生成的SQL**:
```
{generated_sql}
```